题目：
  汉诺塔问题比较经典，修改一下规则：
  现在限制不能从最左侧的塔直接移到最右侧，也不能从最右侧直接移到最左侧，而是必须经过中间塔。
  问题： 求当塔有N层的时候，打印最优移动过程和最优移动总步数。

例子：
  当塔数为两层时，最上层的塔记为1，最下层的塔记为2，则打印：
    Move 1 from left to mid
    Move 1 from mid to right
    Move 2 from left to mid
    Move 1 from right to mid
    Move 1 form mid to left
    Move 2 form mid to right
    Move 1 from left to mid
    Move 1 from mid to right
    It will move 8 steps.
    
 要求：
  1. 递归方法
  2. 非递归方法
  
思路：
  1. 递归方法
    首先，如果只剩最上层的塔需要移动，则有如下处理：
      1. 如果希望从“左”移到“中”，打印“Move 1 from left to mid”
      2. 如果希望从“中”移到“左”，打印“Move 1 from mid to left”
      3. 如果希望从“中”移到“右”，打印“Move 1 from mid to right”
      4. 如果希望从“右”移到“中”，打印“Move 1 from right to mid”
      5. 如果希望从“左”移到“右”，打印“Move 1 from left to mid”和“Move 1 from mid to right”
      6. 如果希望从“右”移到“左”，打印“Move 1 from right to mid”和“Move 1 from mid to left”
      以上过程就是递归的终止条件，也就是只剩上层塔时的打印过程。
    
    接下来，我们分析剩下多层塔的情况：
    如果剩下N层塔，从最上到最下依次为1~N，则右如下判断：
      1. 如果剩下的N层塔都在“左”，希望全部移到“中”，则有三个步骤：
        1）将1-N-1层塔先全部从“左”移到“右”，明显交给递归过程
        2）将第N层塔从“左”移到“中”
        3）在将1~N-1层塔全部从“右”移到“中”。
      2. 如果吧剩下的N层塔从“中”移到“左”，从“中”移到“右”，从“右”移到“中”，过程与情况1同理，一样分解为三步。
      3. 如果剩下的N层塔都在“左”，希望全部移到“右”。则有五个步骤：
        1）将1~N-1层塔先全部从“左”移到“右”，交给递归过程
        2）将第N层塔从“左”移到“中”
        3）将1~N-1层塔从“右”移到“中”
        4）将第N层从“中”移到“右”
        5）将1~N-1层塔从“左”移到“右”，递归过程
      4. 如果剩下的N层塔都在“右”，希望全部移到“左”，过程与情况3相同
      
  // code java
  public int hanoiProblem1(int num, String left, String mid, String right){
    if(num < 1){
      return 0;
    }
    // 前三个String参数为塔的位置，最后两个参数为from 和 to 
    return process(num, left, mid, right, left, right);
  }
  
  public int process(int num, String left, String mid, String right, String from, String to){
    // 最底层
    if(num == 1){
      // 只移动一步（left-->mid,mid-->left,mid-->right,right-->mid） 
      if(from.equals(mid) || to.equals(mid)){
        System.out.println("Move 1 from " + from + " to " + to);
        return 1;
      }
      // 移动两步(left-->mid-->right or right-->mid-->left)
      else{
        System.out.println("Move 1 from " + from + " to " + mid);
        System.out.println("Move 1 from " + mid + " to " + to);
      }
    }
    // 剩下的层数的移动
    // (left-->mid,right-->mid)  三个步骤
    if(from.equals(mid) || to.equals(mid))｛
      // 首先先确定是要移动到哪个地方
      String another = (from.equals(left)) || (to.equals(left)) ? right : left;
      // 将1-N-1移动到对应对方--递归
      int part1 = process(num-1, left, mid, right, from, another);
      // 将第N层移动到to
      System.out.println("Move " + num + " from " + from + " to " + to);
      int part2 = 1;
      // 将剩下的从对应移到中
      int part3 = process(num-1, left, mid, right, another, to);
      return part1 + part2 + part3;
    ｝
    // (left-->mid-->right or right-->mid-->left) 五个步骤
    else{
      // 递归将1~num-1 从from 到 to
      int part1 = process(num-1, left, mid, right, from, to);
      // 将第num从from移到mid
      System.out.println("Move " + num + " from " + from + " to " + mid);
      int part2 = 1;
      // 递归将1~num-1 从to 到 from
      int part3 = process(num-1, left, mid, right, to, from);
      // 将第num层从“中”移到to位置
      System.out.println("Move " + num + " from " + mid + " to " + to);
      int part4 = 1;
      // 递归将1~num-1 从from 到 to
      int part5 = process(num-1, left, mid, right, from, to);
      return part1 + part2 + part3 + part4 + part5；
    }
  }
      
      
      
      
